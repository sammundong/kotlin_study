# 2장 코틀린 기초

## 2.1 기본요소: 함수와 변수

### **함수를 작성하는 **

```kotlin
// 함수이름(파라미터): 리턴타입
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

- 함수의 선언은 fun 키워드로 시작 ( 함수 생성은 재밋다..)
- 함수 이름 뒤에는 괄호 안에 파라미터
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 위치, 단 괄호와 반환 타입 사이를 콜론으로 구분 
<br>

### 함수의 기본 구조


```kotlin
fun max(a: Int, b: Int): Int = if(a>b) a else b
```

- 코틀린의 if는 문장이 아니고 결과를 만드는 식(expression)
  -  식은 값을 만들어 내며, 다른 식의 하위 요소로 계산에 참여 가능
  - 대입문은 자바에서 `식`이었으나 코틀린에서는 `문`의 차이가 있다. 



- '식이 본문인 함수'
  - 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수
  - 등호와 식으로 이뤄진 함수를 식이 본문인 함수
  - '반환 타입을 생략할 수 있는 이뉴 ?'
  - 코틀린은 정적 타입 지정 언어로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해져야 한다.


- 타입 투론(Type Inference)
  - 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능
  - 식이 본문인 함수의 반환 타입만 생략 가능
  - 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정, return 문을 사용해 반드시 타입 명시


<br>

### 변수

- 코틀린에서 변수의 선언
  - 변수 이름 뒤에 타입을 명시하거나 생략을 허용
  - 식이 본문인 함수에서와 마찬가지로 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정
  - 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시
  - 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 이러한 경우 타입을 반드시 지정해야 함


- 변경 가능한 변수와 변경 불가능한 변수
  - val : 변경 불가능한 참조를 저장하는 변수
  - 자바와 final 키워드 
- var : 변경 가능한 참조를 저장하는 변수 
  - 변수의 값은 언제든지 변경 가능
  - 자바의 일반 변수
- 주의사항
  - 변수의 값은 변경이 가능하지만, 변수의 타입은 고정되어 바뀌지 않음
    (가변의 뜻이 타입 자체는 아니다)
  ```kotlin
  var answer = 42
  answer = "no answer" // Error : type mismatch 컴파일 오류 발생
   ```
  - 개발 방식 순서
    - val 키워드를 사용해 불변 변수를 선언, 추후 필요하 경우 var로 변경
    - 변경 불가능한 참조와 변경 불가능한 객체를 부수효과가 없는 함수와 조합해 사용하면 함수형 코드에 가까워진다. 

<br>

## 2.2 클래스와 프로퍼티

  - 클래스의 기본 목적은 데이터를 갭슐화하기 위함
    - 멤버 필드의 가시성은 보통 private
    - 클라이언트가 데이터에 접근하기 위한 방법으로 접근자 메서드(accessor method)를 제공
    - 일반적으로 필드를 읽기 위한 getter 제공, 필드 변경이 필요한 경우 setter 제공
  - 자바에서 프로퍼티의 정이
    - 필드와 getter를 한데 묶어 프로퍼티라 부름
  - 코틀린에서 프로퍼티 정의 

```kotlin
class Person(val name: String, var isMarrid: Boolean)

fun main(){
    val myPerson = Person("name",true)
    myPerson.name // myPerson.getName() -> getter 
    myPerson.isMarrid // myPerson.getIsMarried() -> getter
    myPerson.isMarrid = false // myPerson.SetIsMarried(false)
}
```

<br>

### 커스텀 접근자

- 프로퍼티의 접근자를 사용자 정의로 작성하는 방식


```kotlin
class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        bet(){ // 프로퍼티 getter 재정의
            return height = width
        }
}
```


###  Backing Field: 뒷받침하는 필드 ⭐

- 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 존재
- 객체에 어떠한 로직처리가 이루어진 필드
- 커스텀 게더를 통해 구현 가능

```kotlin
class Test {
    var name: String = ""
        set(value) {
            // field 키워드로 실제 필드에 접근 가능
            // 필드이름을 그대로 사용(value)하면 프로퍼티(getValue(), setValue())로 사용되어 메서드가 무한 재귀할 수 있음. 
            field = if (value.isNotEmpty()) value else ""
        }
}
```



- 프로퍼티와 실제 내부에 생성되는 필드는 다를 수 있음. (컴파일러에 의해 최적화됨)

```kotlin
class Test {
    var size = 0; // 실제 private int size 필드가 생성됨

    var isEmpty // isEmpty 는 프로퍼티로만 존재하고, 실제 필드는 생성하지 않음 (컴파일러에 의한 최적화)
        get() = size == 0
        set(value) {
            size = size * 2
        }
}
```

